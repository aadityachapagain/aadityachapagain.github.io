{"pageProps":{"post":{"slug":"understanding-python-decorator-with-its-usage","title":"Understanding Python Decorator and Its Usage","date":"2022-03-15 12:00","modified":"2022-03-15 12:00","category":"Blog","summary":"Upskill your python using awesome decorators","tags":"Machine Learning, python, coding, decorator, callbacks, developer, python skill,","authors":["Aaditya Chapagain"],"status":"published","content":"<p>You might have seen python code that has <code>@&#x3C;function_or_class></code> written immediately above a function or Class.\nFor Example, <code>@staticmethod</code> right above static method or <code>@classmethod</code> right above class method. Those are\nactually Python decorators. Decorators allow an existing function to be extended without changing the source code.</p>\n<p>In this blog, we will comprehend a decorator structure, examine advanced behaviours including drawbacks and ways to overcome it, nested decorators, stacking decorators and eventually some practical applications, develop our own multi-purpose decorators.</p>\n<h2 id=\"table-of-contents\">Table of contents</h2>\n<ul>\n<li>\n<p><a href=\"#writing-decorator\">Writing Decorator</a></p>\n</li>\n<li>\n<p><a href=\"#advanced-behaviours-of-decorators\">Advanced behaviours of Decorators</a></p>\n<ul>\n<li><a href=\"#retain-metadata-of-wrapped-function\">Retain metadata of wrapped function</a></li>\n<li><a href=\"#decorators-that-accept-arguments\">Decorators that accept arguments</a></li>\n<li><a href=\"#stacking-decorators\">Stacking decorators</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#usage-of-decorators\">Usage of Decorators</a></p>\n<ul>\n<li><a href=\"#measuring-execution-time-of-functions\">Measuring execution time of functions</a></li>\n<li><a href=\"#debug-with-logging\">Debug with logging</a></li>\n<li><a href=\"#registering-plugins\">Registering Plugins</a></li>\n<li><a href=\"#creating-a-singleton-class\">Creating a singleton class</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#references\">REFERENCES</a></p>\n</li>\n</ul>\n<h2 id=\"writing-decorator\">Writing Decorator</h2>\n<p>Decorators are often referred to as function wrappers because they accept a function as a paramter and return a modified version of the function that has additional features or capabilites.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">simple_decorator</span>(<span class=\"hljs-params\">func</span>):\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n    <span class=\"hljs-comment\"># do something before function execution</span>\n    result = func (*args, **kwargs)\n    <span class=\"hljs-comment\"># do something after function execution</span>\n    <span class=\"hljs-keyword\">return</span> result\n  <span class=\"hljs-keyword\">return</span> wrapper\n\n</code></pre>\n<p>we can see from the construct above that line 4 is where the function really executes, but we can change what happens before to, during and even after a function execution. Althouh decorators may alter a function's input, output, or behaviour, it is preferable to build them in a way that does not make the function they are wrapping less understandable.</p>\n<blockquote>\n<p><strong>Decorators are best used to add common behaviour to multiple functions without modifying every function manually</strong></p>\n</blockquote>\n<h2 id=\"advanced-behaviours-of-decorators\">Advanced behaviours of Decorators</h2>\n<h3 id=\"retain-metadata-of-wrapped-function\">Retain metadata of wrapped function</h3>\n<p>One major <strong>drawback</strong> of using decorators is that the metadata of function will be destroyed by decorator when actually calling that function in code, because we are returning a wrapper function in place of the original function in the code sample from the previous section, all decorated functions will have their <code>__name__</code> and <code>signature</code> information changed to wrapper's.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-meta\">@simple_decorator</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">func_add</span>(<span class=\"hljs-params\">a, b</span>):\n  <span class=\"hljs-keyword\">return</span> a + b\n\n<span class=\"hljs-built_in\">print</span>(func_add.__name__)\n<span class=\"hljs-comment\"># wrapper</span>\n\n</code></pre>\n<p>Technically, this wouldn't impact how the fucntion or decorator was meant to be used, but it's still advisable to avoid any unexpected outcomes when using a decorator. This can be accomplished quickly by decorating the wrapper function with the <code>@wraps</code> decorator, as illustrated below.The decorator can still be used in the same way, but now the wrapped function's metadata won't be changed.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">sample_decorator</span>(<span class=\"hljs-params\">func</span>):\n<span class=\"hljs-meta\">  @wraps(<span class=\"hljs-params\">func</span>)</span>\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n    <span class=\"hljs-comment\"># do something before function exec</span>\n    result = func(*args, **kwargs)\n    <span class=\"hljs-comment\"># do something after function exec</span>\n    <span class=\"hljs-keyword\">return</span> result\n  <span class=\"hljs-keyword\">return</span> wrapper\n\n</code></pre>\n<h3 id=\"decorators-that-accept-arguments\">Decorators that accept arguments</h3>\n<p>Under the hood we all know that decorators are just a function wrapper. So, it is possible for decorator to receive arguments to make make this happen , we just need to slight change in coding our decorator.\nWe will get decorator that will take arguments, If only we just wrap the existing decorator with another function with arguments we wanna pass to the decorator. Easy right !.</p>\n<p>Example below I have a <code>debug_decorator</code> that takes parameters and returns a <code>decorator</code> decorator that wraps thea original function in a new one. The several nested function in this can make it appear fairly confusing at first but first creating the original decorator before wrapping it to take argumeants will make it easy to code and understand.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\ndebug_mode = <span class=\"hljs-literal\">True</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">debug_decorator</span>(<span class=\"hljs-params\">debug_mode</span>):\n    <span class=\"hljs-string\">\"\"\"Example: Passing arguments to a decorator\"\"\"</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decorator</span>(<span class=\"hljs-params\">func</span>):\n<span class=\"hljs-meta\">        @wraps(<span class=\"hljs-params\">func</span>)</span>\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n            <span class=\"hljs-keyword\">if</span> debug_mode:\n                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Function called: <span class=\"hljs-subst\">{func.__name__}</span>\"</span>)\n            result = func(*args, **kwargs)\n            <span class=\"hljs-keyword\">return</span> result\n        <span class=\"hljs-keyword\">return</span> wrapper\n    <span class=\"hljs-keyword\">return</span> decorator\n\n\n<span class=\"hljs-meta\">@debug_decorator(<span class=\"hljs-params\">debug_mode</span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">func_add</span>(<span class=\"hljs-params\">a, b</span>):\n    <span class=\"hljs-keyword\">return</span> a + b\n\n\nfunc_add(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\"># Function called: func_add</span>\n<span class=\"hljs-comment\"># 3</span>\n</code></pre>\n<h3 id=\"stacking-decorators\">Stacking decorators</h3>\n<p>Decorators, as previously indicated, permit the extension of current functionalities. To add extra extensions, it is possible to stack several decorators over a function. The decorator will be piled in the same order as tahe order of execution.</p>\n<p>One thing to remember is that if time-sensitive decorators are layered, they should be added at last. So that they can accurately reflect the execution of time without being influeced by other decorators. Decorators that measure the execution of time of a function, for instance, should be the last to be executed.</p>\n<p>Now, that we are familiar with a decorator's structure and sophisticated behaviours, we can explore their actual use!</p>\n<h2 id=\"usage-of-decorators\">Usage of Decorators</h2>\n<h3 id=\"measuring-execution-time-of-functions\">Measuring execution time of functions</h3>\n<p>The <code>timer</code> decorator can measure the execution time of the wrapped function by recording the start time and end time of the function execution and printing the results to the console.</p>\n<p>In the code snippet below, we measure the <code>start_time</code> and <code>end_time</code> before and after function execution.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\">func</span>):\n    <span class=\"hljs-string\">\"\"\"Example: Measure execution time of function\"\"\"</span>\n<span class=\"hljs-meta\">    @wraps(<span class=\"hljs-params\">func</span>)</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Execution time: <span class=\"hljs-subst\">{<span class=\"hljs-built_in\">round</span>(end_time - start_time, <span class=\"hljs-number\">4</span>)}</span>\"</span>)\n        <span class=\"hljs-keyword\">return</span> result\n    <span class=\"hljs-keyword\">return</span> wrapper\n\n\n<span class=\"hljs-meta\">@timer</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">func_add</span>(<span class=\"hljs-params\">a, b</span>):\n    time.sleep(<span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">return</span> a + b\n\n\nfunc_add(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\"># Execution time: 2.0064</span>\n\n</code></pre>\n<h3 id=\"debug-with-logging\">Debug with logging</h3>\n<p>The <code>logging</code> decorator can be used to log information to a console or log file and is useful for debugging. Below we'll use the <code>logging</code> python package to perform logging.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">import</span> logging\n\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">logging</span>(<span class=\"hljs-params\">func</span>):\n    <span class=\"hljs-string\">\"\"\"Example: Logging with decorator\"\"\"</span>\n\n<span class=\"hljs-meta\">    @wraps(<span class=\"hljs-params\">func</span>)</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n        log_time = datetime.today().strftime(<span class=\"hljs-string\">\"%Y-%m-%d %H:%M:%S\"</span>)\n        logger.info(<span class=\"hljs-string\">f\"<span class=\"hljs-subst\">{log_time}</span>: <span class=\"hljs-subst\">{func.__name__}</span> called\"</span>)\n        result = func(*args, **kwargs)\n        <span class=\"hljs-keyword\">return</span> result\n    <span class=\"hljs-keyword\">return</span> wrapper\n\n</code></pre>\n<h3 id=\"registering-plugins\">Registering Plugins</h3>\n<p>Decorators don’t have to wrap the function they’re decorating. They can also simply register that a function exists and return it unwrapped. This can be used, for instance, to create a light-weight plug-in architecture:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> random\nPLUGINS = <span class=\"hljs-built_in\">dict</span>()\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\">func</span>):\n    <span class=\"hljs-string\">\"\"\"Register a function as a plug-in\"\"\"</span>\n    PLUGINS[func.__name__] = func\n    <span class=\"hljs-keyword\">return</span> func\n\n<span class=\"hljs-meta\">@register</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">say_hello</span>(<span class=\"hljs-params\">name</span>):\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f\"Hello <span class=\"hljs-subst\">{name}</span>\"</span>\n\n<span class=\"hljs-meta\">@register</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">be_awesome</span>(<span class=\"hljs-params\">name</span>):\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f\"Yo <span class=\"hljs-subst\">{name}</span>, together we are the awesomest!\"</span>\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">randomly_greet</span>(<span class=\"hljs-params\">name</span>):\n    greeter, greeter_func = random.choice(<span class=\"hljs-built_in\">list</span>(PLUGINS.items()))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Using <span class=\"hljs-subst\">{greeter!r}</span>\"</span>)\n    <span class=\"hljs-keyword\">return</span> greeter_func(name)\n\n</code></pre>\n<p>The <code>@register</code> decorator simply stores a reference to the decorated function in the global <code>PLUGINS</code> dict. Note that you do not have to write an inner function or use @functools.wraps in this example because you are returning the original function unmodified.</p>\n<p>The randomly_greet() function randomly chooses one of the registered functions to use. Note that the PLUGINS dictionary already contains references to each function object that is registered as a plugin:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-meta\">>>> </span>PLUGINS\n{<span class=\"hljs-string\">'say_hello'</span>: &#x3C;function say_hello at <span class=\"hljs-number\">0x7f768eae6730</span>>,\n <span class=\"hljs-string\">'be_awesome'</span>: &#x3C;function be_awesome at <span class=\"hljs-number\">0x7f768eae67b8</span>>}\n\n<span class=\"hljs-meta\">>>> </span>randomly_greet(<span class=\"hljs-string\">\"Alice\"</span>)\nUsing <span class=\"hljs-string\">'say_hello'</span>\n<span class=\"hljs-string\">'Hello Alice'</span>\n\n</code></pre>\n<p>The main benefit of this simple plugin architecture is that you do not need to maintain a list of which plugins exist. That list is created when the plugins register themselves. This makes it trivial to add a new plugin: just define the function and decorate it with <code>@register</code>.</p>\n<p>If you are familiar with <code>globals()</code> in Python, you might see some similarities to how the plugin architecture works. <code>globals()</code> gives access to all global variables in the current scope, including your plugins:</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-meta\">>>> </span><span class=\"hljs-built_in\">globals</span>()\n{..., <span class=\"hljs-comment\"># Lots of variables not shown here.</span>\n <span class=\"hljs-string\">'say_hello'</span>: &#x3C;function say_hello at <span class=\"hljs-number\">0x7f768eae6730</span>>,\n <span class=\"hljs-string\">'be_awesome'</span>: &#x3C;function be_awesome at <span class=\"hljs-number\">0x7f768eae67b8</span>>,\n <span class=\"hljs-string\">'randomly_greet'</span>: &#x3C;function randomly_greet at <span class=\"hljs-number\">0x7f768eae6840</span>>}\n\n</code></pre>\n<p>Using the <code>@register</code> decorator, you can create your own curated list of interesting variables, effectively hand-picking some functions from <code>globals()</code>.</p>\n<h3 id=\"creating-a-singleton-class\">Creating a singleton class</h3>\n<blockquote>\n<p><strong>Singleton class is a design pattern that restricts the instantiation of a class and ensures that only one instance of the class exists.</strong></p>\n</blockquote>\n<p>Singleton class is helpful when there is a cap on the number of concurrent users who can use a shared resource or when there is only one point of access to a resource. In python singleton class can be created just using decorator.</p>\n<p>Single instantiation can be guaranteed by specifically coding singleton classes. But, utilising decorators is a clever method to reuse the code for several classes if there are several singleton classes.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">singleton</span>(<span class=\"hljs-params\">cls</span>):\n    <span class=\"hljs-string\">\"\"\"Example: Create singleton class with decorator\"\"\"</span>\n    instances = {}\n\n<span class=\"hljs-meta\">    @wraps(<span class=\"hljs-params\">cls</span>)</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n        <span class=\"hljs-keyword\">if</span> cls <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> instances:\n            instances[cls] = cls(*args, **kwargs)\n        <span class=\"hljs-keyword\">return</span> instances[cls]\n    <span class=\"hljs-keyword\">return</span> wrapper\n\n\n<span class=\"hljs-meta\">@singleton</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SampleClass</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-keyword\">pass</span>\n\n\nsingleton_class = SampleClass()\nsingleton_class2 = SampleClass()\n<span class=\"hljs-built_in\">print</span>(singleton_class == singleton_class2)\n<span class=\"hljs-comment\"># True</span>\n\n</code></pre>\n<p>Hope, you now have a solid understanding of decorators fundamentals, practical advice and real-world examples. Other applications include the use of decorator for caching, memory management, and timeout precedures. These decorators are more sophisticated, thus using built-in decorators from python or decorators from 3^rd party python packages is preferable to creating them from scratch.</p>\n<p>Hope In future , I will come up with new blog posts explaining all the really really complicated python decorators.</p>\n<h2 id=\"references\">REFERENCES</h2>\n<ul>\n<li>\n<p><a href=\"https://www.wikiwand.com/en/Singleton_pattern\">https://www.wikiwand.com/en/Singleton_pattern</a></p>\n</li>\n<li>\n<p><a href=\"https://peps.python.org/pep-0318/\">https://peps.python.org/pep-0318/</a></p>\n</li>\n<li>\n<p><a href=\"https://realpython.com/primer-on-python-decorators/\">https://realpython.com/primer-on-python-decorators/</a></p>\n</li>\n</ul>"}},"__N_SSG":true}