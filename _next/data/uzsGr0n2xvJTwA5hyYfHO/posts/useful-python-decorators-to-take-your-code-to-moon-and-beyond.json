{"pageProps":{"post":{"slug":"useful-python-decorators-to-take-your-code-to-moon-and-beyond","title":"Useful Python decorator to take your code to MARS and beyond","date":"2022-04-15 12:00","modified":"2022-04-15 12:00","category":"Blog","summary":"Do more thing with less code without compromising on quality","tags":"Machine Learning, python, coding, decorator, callbacks, developer, python skill,","authors":["Aaditya Chapagain"],"status":"published","content":"<p>In this blog post, we will explore 10 helpful decorators which I regularly use in my projects to extend my mode with extra functionalites. We'll dive into each decorator, look at the code and play with some hands-on examples. If you are also Python developer, these decorators will help you massively in your python projects.</p>\n<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#logger\">@logger</a></li>\n<li><a href=\"#lru_cache\">@lru_cache</a></li>\n<li><a href=\"#repeat\">@repeat</a></li>\n<li><a href=\"#timeit\">@timeit</a></li>\n<li><a href=\"#retry\">@retry</a></li>\n<li><a href=\"#countcall\">@countcall</a></li>\n<li><a href=\"#rate_limited\">@rate_limited</a></li>\n<li><a href=\"#register\">@register</a></li>\n<li><a href=\"#dataclass\">@dataclass</a></li>\n<li><a href=\"#singledispatch\">@singledispatch</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ol>\n<h2 id=\"logger\">@logger</h2>\n<p>If you are unfamiliar with decorators, consider reading my previous <a href=\"https://aadityachapagain.com/posts/understanding-python-decorator-with-its-usage\">blog post</a>.</p>\n<p>logger is a function that takes a function as input and return a function as output.The output function is usually an extended version of the input. In our case, we want the output function to surround the call of the input function with <code>start</code> and <code>end</code> statements.</p>\n<p>Here's the simple implementation of the <code>logger</code> decorator.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">logger</span>(<span class=\"hljs-params\">func</span>):\n<span class=\"hljs-meta\">  @wraps(<span class=\"hljs-params\">func</span>)</span>\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"----- <span class=\"hljs-subst\">{function.__name__}</span>: start -----\"</span>)\n    output = func(*args, **kwargs)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"----- <span class=\"hljs-subst\">{function.__name__}</span>: end -----\"</span>)\n    <span class=\"hljs-keyword\">return</span> output\n  <span class=\"hljs-keyword\">return</span> wrapper\n\n\n<span class=\"hljs-comment\"># now you can apply logger to any other functions</span>\n<span class=\"hljs-meta\">@logger</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">some_func</span>(<span class=\"hljs-params\">text</span>):\n  <span class=\"hljs-comment\"># do something here</span>\n\n</code></pre>\n<h2 id=\"lru_cache\">@lru_cache</h2>\n<p>This is a built-in decorator that you can import from <code>functools</code>.</p>\n<p>It caches the return values of a function , using a least-recently-used( LRU ) algorithm to discard the least-used values when the cache is full.</p>\n<p>I typically use this decorator for long-running tasks that don't change the output with the same input like querying a database, requesting a static remote web page, or running some heavy processing.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">import</span> random\n<span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> lru_cache\n\n\n<span class=\"hljs-meta\">@lru_cache(<span class=\"hljs-params\">maxsize=<span class=\"hljs-literal\">None</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">heavy_processing</span>(<span class=\"hljs-params\">n</span>):\n    sleep_time = n + random.random()\n    time.sleep(sleep_time)\n\n<span class=\"hljs-comment\"># first time</span>\n%%time\nheavy_processing(<span class=\"hljs-number\">0</span>)\n<span class=\"hljs-comment\"># CPU times: user 363 µs, sys: 727 µs, total: 1.09 ms</span>\n<span class=\"hljs-comment\"># Wall time: 694 ms</span>\n\n<span class=\"hljs-comment\"># second time</span>\n%%time\nheavy_processing(<span class=\"hljs-number\">0</span>)\n<span class=\"hljs-comment\"># CPU times: user 4 µs, sys: 0 ns, total: 4 µs</span>\n<span class=\"hljs-comment\"># Wall time: 8.11 µs</span>\n\n<span class=\"hljs-comment\"># third time</span>\n%%time\nheavy_processing(<span class=\"hljs-number\">0</span>)\n<span class=\"hljs-comment\"># CPU times: user 5 µs, sys: 1 µs, total: 6 µs</span>\n<span class=\"hljs-comment\"># Wall time: 7.15 µs</span>\n\n</code></pre>\n<p>if you want to implement a cache decorator yourself from scratch, here's how you'd do it:</p>\n<ul>\n<li>You add an empty dictionary as an attribute to the wrapper function to store previously computed values by the input function</li>\n<li>When calling the input function, you first check if its arguments are present in the cache. If it's the case, return the result. Otherwise, compute it and put it in the cache.</li>\n</ul>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cache</span>(<span class=\"hljs-params\">function</span>):\n<span class=\"hljs-meta\">    @wraps(<span class=\"hljs-params\">function</span>)</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n        cache_key = args + <span class=\"hljs-built_in\">tuple</span>(kwargs.items())\n        <span class=\"hljs-keyword\">if</span> cache_key <span class=\"hljs-keyword\">in</span> wrapper.cache:\n            output = wrapper.cache[cache_key]\n        <span class=\"hljs-keyword\">else</span>:\n            output = function(*args)\n            wrapper.cache[cache_key] = output\n        <span class=\"hljs-keyword\">return</span> output\n    wrapper.cache = <span class=\"hljs-built_in\">dict</span>()\n    <span class=\"hljs-keyword\">return</span> wrapper\n\n<span class=\"hljs-meta\">@cache</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">heavy_processing</span>(<span class=\"hljs-params\">n</span>):\n    sleep_time = n + random.random()\n    time.sleep(sleep_time)\n\n\n%%time\nheavy_processing(<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-comment\"># CPU times: user 446 µs, sys: 864 µs, total: 1.31 ms</span>\n<span class=\"hljs-comment\"># Wall time: 1.06 s</span>\n\n%%time\nheavy_processing(<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-comment\"># CPU times: user 11 µs, sys: 0 ns, total: 11 µs</span>\n<span class=\"hljs-comment\"># Wall time: 13.1 µs</span>\n\n</code></pre>\n<h2 id=\"repeat\">@repeat</h2>\n<p>This decorator causes a function to be called multiple times in a row.</p>\n<p>This can be useful for debugging purposes, stress tests, or automating the repetition of multiple tasks.</p>\n<p>Unlike the previous decorators, this one expects an input parameter.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-params\">number_of_times</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decorate</span>(<span class=\"hljs-params\">func</span>):\n<span class=\"hljs-meta\">        @wraps(<span class=\"hljs-params\">func</span>)</span>\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n            <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(number_of_times):\n                func(*args, **kwargs)\n        <span class=\"hljs-keyword\">return</span> wrapper\n    <span class=\"hljs-keyword\">return</span> decorate\n\n\n<span class=\"hljs-meta\">@repeat(<span class=\"hljs-params\"><span class=\"hljs-number\">5</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dummy</span>():\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"hello\"</span>)\n\ndummy()\n<span class=\"hljs-comment\"># hello</span>\n<span class=\"hljs-comment\"># hello</span>\n<span class=\"hljs-comment\"># hello</span>\n<span class=\"hljs-comment\"># hello</span>\n<span class=\"hljs-comment\"># hello</span>\n\n</code></pre>\n<h2 id=\"timeit\">@timeit</h2>\n<p>This decorator measures the execution time of a function and prints the result: this serves as debugging or monitoring.</p>\n<p>In the following snippet, the <code>timeit</code> decorator measures the time it takes for the <code>process_data</code> function to execute and prints out the elapsed time in seconds.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">timeit</span>(<span class=\"hljs-params\">func</span>):\n<span class=\"hljs-meta\">  @wraps(<span class=\"hljs-params\">func</span>):</span>\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n    start = time.perf_counter()\n    result = func(*args, **kwargs)\n    end = time.perf_counter()\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f'<span class=\"hljs-subst\">{func.__name__}</span> took <span class=\"hljs-subst\">{end - start:<span class=\"hljs-number\">.6</span>f}</span> seconds to complete'</span>)\n    <span class=\"hljs-keyword\">return</span> result\n  <span class=\"hljs-keyword\">return</span> wrapper\n\n<span class=\"hljs-meta\">@timeit</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_data</span>():\n  time.sleep(<span class=\"hljs-number\">1</span>)\n\nprocess_data()\n\n</code></pre>\n<h2 id=\"retry\">@retry</h2>\n<p>This decorator forces a function to retry a number of times when it encounters an exception.</p>\n<p>It takes three arguments: the number of retries, the exception to catch and retry on, and the sleep time between retries.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">import</span> random\n<span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">retry</span>(<span class=\"hljs-params\">num_retries, exception_to_check, sleep_time=<span class=\"hljs-number\">0</span></span>):\n    <span class=\"hljs-string\">\"\"\"\n    Decorator that retries the execution of a function if it raises a specific exception.\n    \"\"\"</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decorate</span>(<span class=\"hljs-params\">func</span>):\n<span class=\"hljs-meta\">        @wraps(<span class=\"hljs-params\">func</span>)</span>\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, num_retries+<span class=\"hljs-number\">1</span>):\n                <span class=\"hljs-keyword\">try</span>:\n                    <span class=\"hljs-keyword\">return</span> func(*args, **kwargs)\n                <span class=\"hljs-keyword\">except</span> exception_to_check <span class=\"hljs-keyword\">as</span> e:\n                    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"<span class=\"hljs-subst\">{func.__name__}</span> raised <span class=\"hljs-subst\">{e.__class__.__name__}</span>. Retrying...\"</span>)\n                    <span class=\"hljs-keyword\">if</span> i &#x3C; num_retries:\n                        time.sleep(sleep_time)\n            <span class=\"hljs-comment\"># Raise the exception if the function was not successful after the specified number of retries</span>\n            <span class=\"hljs-keyword\">raise</span> e\n        <span class=\"hljs-keyword\">return</span> wrapper\n    <span class=\"hljs-keyword\">return</span> decorate\n\n<span class=\"hljs-meta\">@retry(<span class=\"hljs-params\">num_retries=<span class=\"hljs-number\">3</span>, exception_to_check=ValueError, sleep_time=<span class=\"hljs-number\">1</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">random_value</span>():\n    value = random.randint(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>)\n    <span class=\"hljs-keyword\">if</span> value == <span class=\"hljs-number\">3</span>:\n        <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">\"Value cannot be 3\"</span>)\n    <span class=\"hljs-keyword\">return</span> value\n\nrandom_value()\n<span class=\"hljs-comment\"># random_value raised ValueError. Retrying...</span>\n<span class=\"hljs-comment\"># 1</span>\n\nrandom_value()\n<span class=\"hljs-comment\"># 5</span>\n\n</code></pre>\n<h2 id=\"countcall\">@countcall</h2>\n<p>This decorator counts the number of times a function has been called.</p>\n<p>This number is stored in the wrapper attribute <code>count</code>.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">countcall</span>(<span class=\"hljs-params\">func</span>):\n<span class=\"hljs-meta\">    @wraps(<span class=\"hljs-params\">func</span>)</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n        wrapper.count += <span class=\"hljs-number\">1</span>\n        result = func(*args, **kwargs)\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f'<span class=\"hljs-subst\">{func.__name__}</span> has been called <span class=\"hljs-subst\">{wrapper.count}</span> times'</span>)\n        <span class=\"hljs-keyword\">return</span> result\n    wrapper.count = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">return</span> wrapper\n\n<span class=\"hljs-meta\">@countcall</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_data</span>():\n    <span class=\"hljs-keyword\">pass</span>\n\nprocess_data()\nprocess_data has been called <span class=\"hljs-number\">1</span> times\nprocess_data()\nprocess_data has been called <span class=\"hljs-number\">2</span> times\nprocess_data()\nprocess_data has been called <span class=\"hljs-number\">3</span> times\n</code></pre>\n<h2 id=\"rate_limited\">@rate_limited</h2>\n<p>This is a decorator that limits the rate at which a function can be called, by sleeping an amount of time if the function is called too frequently.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">rate_limited</span>(<span class=\"hljs-params\">max_per_second</span>):\n    min_interval = <span class=\"hljs-number\">1.0</span> / <span class=\"hljs-built_in\">float</span>(max_per_second)\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decorate</span>(<span class=\"hljs-params\">func</span>):\n        last_time_called = <span class=\"hljs-number\">0.0</span>\n<span class=\"hljs-meta\">        @wraps(<span class=\"hljs-params\">func</span>)</span>\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">rate_limited_function</span>(<span class=\"hljs-params\">*args, **kargs</span>):\n            elapsed = time.perf_counter() - last_time_called\n            left_to_wait = min_interval - elapsed\n            <span class=\"hljs-keyword\">if</span> left_to_wait > <span class=\"hljs-number\">0</span>:\n                time.sleep(left_to_wait)\n            ret = func(*args, **kargs)\n            last_time_called = time.perf_counter()\n            <span class=\"hljs-keyword\">return</span> ret\n        <span class=\"hljs-keyword\">return</span> rate_limited_function\n    <span class=\"hljs-keyword\">return</span> decorate\n\n</code></pre>\n<blockquote>\n<p>This function hence introduces a slight time overhead between the calls but ensures that the rate limit is not exceeded.</p>\n</blockquote>\n<p>There's also a third-party package that implements API rate limit: it's called <strong>ratelimit</strong>.</p>\n<pre><code class=\"hljs language-bash\">pip install ratelimit\n</code></pre>\n<p>To use this package, simply decorate any function that makes an API call:</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">from</span> ratelimit <span class=\"hljs-keyword\">import</span> limits\n\n<span class=\"hljs-keyword\">import</span> requests\n\nFIFTEEN_MINUTES = <span class=\"hljs-number\">900</span>\n\n<span class=\"hljs-meta\">@limits(<span class=\"hljs-params\">calls=<span class=\"hljs-number\">15</span>, period=FIFTEEN_MINUTES</span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">call_api</span>(<span class=\"hljs-params\">url</span>):\n  response = requests.get(url)\n\n  <span class=\"hljs-keyword\">if</span> response.status_code != <span class=\"hljs-number\">200</span>:\n    <span class=\"hljs-keyword\">raise</span> Execption(<span class=\"hljs-string\">'API response: {}'</span>.<span class=\"hljs-built_in\">format</span>(response.status_code))\n  <span class=\"hljs-keyword\">return</span> response\n\n</code></pre>\n<p>if the decorated function is called more times than allowed a <code>ratelimit.RateLimitException</code> is raised.</p>\n<p>To be able to handle this exception, you can use the <code>sleep_and_retry</code> decorator in combination with the <code>ratelimit</code> decorator.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-meta\">@sleep_and_retry</span>\n<span class=\"hljs-meta\">@limits(<span class=\"hljs-params\">calls=<span class=\"hljs-number\">15</span>, period=FIFTEEN_MINUTES</span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">call_api</span>(<span class=\"hljs-params\">url</span>):\n    response = requests.get(url)\n\n    <span class=\"hljs-keyword\">if</span> response.status_code != <span class=\"hljs-number\">200</span>:\n        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">'API response: {}'</span>.<span class=\"hljs-built_in\">format</span>(response.status_code))\n    <span class=\"hljs-keyword\">return</span> response\n</code></pre>\n<p>This causes the function to sleep the remaining amount of time before being executed again.</p>\n<h2 id=\"register\">@register</h2>\n<p>If your pyton script accidentally terminates and you still want to perform some tasks to save your work, perform some tasks to save your work, perform cleanup or print a message, I find that the register decorator is quite handy in this context.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">from</span> atexit <span class=\"hljs-keyword\">import</span> register\n\n<span class=\"hljs-meta\">@register</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">terminate</span>():\n    perform_some_cleanup()\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Goodbye!\"</span>)\n\n<span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello\"</span>)\n\n</code></pre>\n<h2 id=\"dataclass\">@dataclass</h2>\n<p>The <code>@dataclass</code> decorator in Python is used to decorate classes.</p>\n<p>It automatically generates special methods such as <code>__init__</code>, <code>__repr__</code>,\n<code>__eq__</code>, <code>__lt__</code>, and <code>__str__</code> for classes that primarily store data. This can reduce the boilerplate code and make the classes more readable and maintainable.</p>\n<p>It also provides nifty methods off-the-shelf to represent objects nicely, convert them into JSON format, make them immutable, etc.</p>\n<p>The <code>@dataclass</code> decorator was introduced in Python 3.7 and is available in the standard library.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">from</span> dataclasses <span class=\"hljs-keyword\">import</span> dataclass,\n\n<span class=\"hljs-meta\">@dataclass</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>:\n    first_name: <span class=\"hljs-built_in\">str</span>\n    last_name: <span class=\"hljs-built_in\">str</span>\n    age: <span class=\"hljs-built_in\">int</span>\n    job: <span class=\"hljs-built_in\">str</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__eq__</span>(<span class=\"hljs-params\">self, other</span>):\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">isinstance</span>(other, Person):\n            <span class=\"hljs-keyword\">return</span> self.age == other.age\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NotImplemented</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__lt__</span>(<span class=\"hljs-params\">self, other</span>):\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">isinstance</span>(other, Person):\n            <span class=\"hljs-keyword\">return</span> self.age &#x3C; other.age\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NotImplemented</span>\n\n\njohn = Person(first_name=<span class=\"hljs-string\">\"John\"</span>,\n              last_name=<span class=\"hljs-string\">\"Doe\"</span>,\n              age=<span class=\"hljs-number\">30</span>,\n              job=<span class=\"hljs-string\">\"doctor\"</span>,)\n\nanne = Person(first_name=<span class=\"hljs-string\">\"Anne\"</span>,\n              last_name=<span class=\"hljs-string\">\"Smith\"</span>,\n              age=<span class=\"hljs-number\">40</span>,\n              job=<span class=\"hljs-string\">\"software engineer\"</span>,)\n\n<span class=\"hljs-built_in\">print</span>(john == anne)\n<span class=\"hljs-comment\"># False</span>\n\n<span class=\"hljs-built_in\">print</span>(anne > john)\n<span class=\"hljs-comment\"># True</span>\n\nasdict(anne)\n<span class=\"hljs-comment\">#{'first_name': 'Anne',</span>\n<span class=\"hljs-comment\"># 'last_name': 'Smith',</span>\n<span class=\"hljs-comment\"># 'age': 40,</span>\n<span class=\"hljs-comment\"># 'job': 'software engineer'}</span>\n\n</code></pre>\n<h2 id=\"singledispatch\">@singledispatch</h2>\n<p>This decorator allows a function to have different implementations for different types of arguments.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> singledispatch\n\n<span class=\"hljs-meta\">@singledispatch</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fun</span>(<span class=\"hljs-params\">arg</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Called with a single argument\"</span>)\n\n<span class=\"hljs-meta\">@fun.register(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_</span>(<span class=\"hljs-params\">arg</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Called with an integer\"</span>)\n\n<span class=\"hljs-meta\">@fun.register(<span class=\"hljs-params\"><span class=\"hljs-built_in\">list</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_</span>(<span class=\"hljs-params\">arg</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Called with a list\"</span>)\n\nfun(<span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\"># Prints \"Called with an integer\"</span>\nfun([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>])  <span class=\"hljs-comment\"># Prints \"Called with a list\"</span>\n\n</code></pre>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Decorators are useful abstractions to extend your code with extra functionalities like caching, automatic retry, rate limiting, logging, or turning your classes into supercharged data containers.</p>\n<p>Here's a <a href=\"https://github.com/lord63/awesome-python-decorator\">list</a> of awesome decorators to get inspired.</p>\n<p>Thanks for reading!.</p>"}},"__N_SSG":true}