{"pageProps":{"post":{"slug":"testing-in-go-nutshell","title":"Testing Go Program in Nutshell.","date":"2020-08-11 8:00","modified":"2020-08-11 8:00","category":"Blog","summary":"Testing Framework in Go is extremely simple and minimal","tags":"Go, Golang, Test, Testing, software development, Programming language, TDD","authors":["Aaditya Chapagain"],"status":"published","content":"<h2 id=\"table-of-contents\">Table of contents</h2>\n<ul>\n<li><a href=\"#the-go-test-tool\">The GO test Tool</a></li>\n<li><a href=\"#test-functions\">Test Functions</a></li>\n<li><a href=\"#benchmark-function\">Benchmark Function</a></li>\n</ul>\n<h1 id=\"the-go-test-tool\">The GO test Tool</h1>\n<p>Testing in Go starts with <code>go test</code> subcommand i.e. test driver for Go packages that are organized according to certain conventions. <code>go test</code> command specifically looks and execute files that ends with <strong>_test.go</strong> which are not part of the package when built by <code>go build </code>.</p>\n<p>The Go test files contains three kinds of special functions :</p>\n<ul>\n<li>\n<p>A <em>test function</em>: Function which name starts with <code>Test</code>. This function exercises some program logic for correct behaviour; subcommand <code>go test</code> calls the test function and reports the result which is either <code>PASS</code> or <code>FAIL</code>.</p>\n</li>\n<li>\n<p>A <em>benchmark function</em>: It has the name beginning with <code>Benchmark</code> and measures the performance of some operations; subcommand <code>go test</code> reports the mean execution time of the operation.</p>\n</li>\n<li>\n<p>An <em>example function</em>: Its name starts with <code>Example</code> provides machine-checked documentation.</p>\n</li>\n</ul>\n<p>The <code>go test</code> tool scans the *_test.go files for these special functions, generates a temporary main package that calls them all in the proper way, builds and runs it, reports the result, and then cleans up.</p>\n<h1 id=\"test-functions\">Test Functions</h1>\n<p>Each test file must import the testing package. Test functions has following signature :</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestName</span><span class=\"hljs-params\">(t *testing.T)</span></span> {\n  <span class=\"hljs-comment\">// ..</span>\n}\n\n</code></pre>\n<p>Test function names must begin with Test; The optional suffix Name must begin with a capital letter:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestSin</span><span class=\"hljs-params\">(t *testing.T)</span></span> { <span class=\"hljs-comment\">// ... }</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestCos</span><span class=\"hljs-params\">(t *testing.T)</span></span> { <span class=\"hljs-comment\">// ... }</span>\n</code></pre>\n<p>The t parameter provides methods for reporting test failures and logging additional information. Lets create a new package palindrome containing a single function IsPalindrome that reports whether a string a string reads same forward and backward.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> palindrome\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">IsPalidrome</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> {\n  <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> s {\n    <span class=\"hljs-keyword\">if</span> s[i] != s[<span class=\"hljs-built_in\">len</span>(s) - <span class=\"hljs-number\">1</span> - i] {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n\n</code></pre>\n<p>In the same directory, the palindrome_test.go contains two test functions named TestPalindrome and TestNonPalindrome. Each check that IsPalindrome gives the right answer for a single input and reports failures using t.Errorf:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> palindrome\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestPalindrome</span><span class=\"hljs-params\">(t *testing.T)</span></span> {\n  <span class=\"hljs-keyword\">if</span> !IsPalindrome(<span class=\"hljs-string\">\"detartrated\"</span>) {\n    t.Errorf(<span class=\"hljs-string\">`IsPalindrome(\"detartrated\") = false`</span>)\n  }\n  <span class=\"hljs-keyword\">if</span> !IsPalindrome(<span class=\"hljs-string\">\"kayak\"</span>) {\n    t.Errorf(<span class=\"hljs-string\">`IsPalindrome(\"kayak\") = false`</span>)\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestNonPalindrome</span><span class=\"hljs-params\">(t *testing.T)</span></span> {\n  <span class=\"hljs-keyword\">if</span> IsPalindrome(<span class=\"hljs-string\">\"palindrome\"</span>) {\n    t.Error(<span class=\"hljs-string\">`IsPalindrome(\"palindrome\") = true`</span>)\n  }\n}\n\n</code></pre>\n<p>Now,we already have test code to test our functionality, we can use go test command to run tests in go.\nRemember <code>go test palindrome</code> will run the package level test.For this to work you have to place your package in either <code>$GOROOT</code> or <code>$GOPATH</code> directory.\nIn our case we can test our functionlity by going into pacakge directory.</p>\n<pre><code class=\"hljs language-bash\">> <span class=\"hljs-built_in\">cd</span> &#x3C;path_to_project_dir>/palindrome\n> go <span class=\"hljs-built_in\">test</span>\n\nPASS\nok  \t&#x3C;path_to_project_dir>/palindrome\t0.001s\n</code></pre>\n<p>To look into more details on test function, To see which one failed and which one succeed, we can use <code>-v</code> flag , which will prints the name and execution time of each test in the package.</p>\n<pre><code class=\"hljs language-bash\">> go <span class=\"hljs-built_in\">test</span> -v\n\n=== RUN TestPalindrome\n--- PASS: TestPalindrome (0.00s)\n=== RUN TestNonPalindrome\n--- PASS: TestNonPalindrome (0.00s)\n=== RUN TestFrenchPalindrome\n--- FAIL: TestFrenchPalindrome (0.00s)\nword_test.go:28: IsPalindrome(<span class=\"hljs-string\">\"été\"</span>) = <span class=\"hljs-literal\">false</span>\n=== RUN TestCanalPalindrome\n--- FAIL: TestCanalPalindrome (0.00s)\nword_test.go:35: IsPalindrome(<span class=\"hljs-string\">\"A man, a plan, a canal: Panama\"</span>) = <span class=\"hljs-literal\">false</span>\nFAIL\n<span class=\"hljs-built_in\">exit</span> status 1\nFAIL  &#x3C;path_to_project_dir>/palindrome 0.001s\n\n</code></pre>\n<p>and the -run flag, whose argument is a regular expression, causes go test to run only those tests whose function name matches the patter:</p>\n<pre><code class=\"hljs language-bash\">\n> go <span class=\"hljs-built_in\">test</span> -v -run=<span class=\"hljs-string\">\"French|Canal\"</span>\n=== RUN TestFrenchPalindrome\n--- FAIL: TestFrenchPalindrome (0.00s)\nword_test.go:28: IsPalindrome(<span class=\"hljs-string\">\"été\"</span>) = <span class=\"hljs-literal\">false</span>\n=== RUN TestCanalPalindrome\n--- FAIL: TestCanalPalindrome (0.00s)\nword_test.go:35: IsPalindrome(<span class=\"hljs-string\">\"A man, a plan, a canal: Panama\"</span>) = <span class=\"hljs-literal\">false</span>\nFAIL\n<span class=\"hljs-built_in\">exit</span> status 1\nFAIL  &#x3C;path_to_project_dir>/palindrome 0.001s\n\n</code></pre>\n<h1 id=\"benchmark-function\">Benchmark Function</h1>\n<p>Benchmarking is the practice of measuring the performance of a program on a fixed workload. In Go, a benchmark function look like a test function, but with the\nBenchmark prefix and a *testing.B parameter that provides most of the same methods as a *testing.T, plus few extra related performance measurement.It also exposes\nan Integer field N, which specifies the number of times to perform the operation being measured.</p>\n<p>Here's a benchmark for IsPalindrome that calls it N times in a loop.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BenchmarkIsPalindrome</span><span class=\"hljs-params\">(b *testing.B)</span></span> {\n  <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &#x3C; b.N; i++ {\n    IsPalindrome(<span class=\"hljs-string\">\"A man, a plan, a canal: Panama\"</span>)\n  }\n}\n</code></pre>\n<p>Unlike tests, by default no benchmarks are run. The argument to the -bench flag selects which benchmark to run. It is regular expression matching the names of Benchmark functions, with a default value that matches none of the functions. The \".\" pattern causes it to match all benchmark functions in package.</p>\n<pre><code class=\"hljs language-bash\">> go <span class=\"hljs-built_in\">test</span> -bench=.\ngoos: linux\ngoarch: amd64\nBenchmarkIsPalindrome-12    \t 4377900\t       301 ns/op\nPASS\nok  \t&#x3C;path_to_project_dir>/palindrome\t1.598s\n</code></pre>\n<p>The benchmark name’s numeric suffix, 12 here , indicates the value of GOMAXPROCS, which is important for concurrent benchmarks.</p>\n<p>The report tells us that each call to <em>IsPalindrome</em> took about 0.301 microseconds, averaged over 4377900 runs. Since the benchmark runner initially has no idea how long the operation takes, it make some initial measuremetns using small values of N and then extrapolates to a value large enough for a stable timing measurement to be made.</p>"}},"__N_SSG":true}